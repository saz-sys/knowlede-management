---
description: "計画を実行可能なタスクに分解します。これは仕様駆動開発ライフサイクルの第3ステップです。"
---

計画を実行可能なタスクに分解します。

これは仕様駆動開発ライフサイクルの第3ステップです。

引数として提供されたコンテキストに基づいて、以下を実行してください：

1. リポジトリルートから `scripts/check-task-prerequisites.sh --json` を実行し、FEATURE_DIRとAVAILABLE_DOCSリストを解析します。すべてのパスは絶対パスである必要があります。
2. 利用可能な設計ドキュメントを読み込んで分析します：
   - 技術スタックとライブラリについて常にplan.mdを読み込み
   - 存在する場合：エンティティについてdata-model.mdを読み込み
   - 存在する場合：APIエンドポイントについてcontracts/を読み込み
   - 存在する場合：技術的決定についてresearch.mdを読み込み
   - 存在する場合：テストシナリオについてquickstart.mdを読み込み

   注意：すべてのプロジェクトがすべてのドキュメントを持つわけではありません。例：
   - CLIツールはcontracts/を持たない場合があります
   - シンプルなライブラリはdata-model.mdを必要としない場合があります
   - 利用可能なものに基づいてタスクを生成します

3. テンプレートに従ってタスクを生成します：
   - `/templates/tasks-template.md` をベースとして使用
   - 以下に基づいて例のタスクを実際のタスクに置き換えます：
     * **セットアップタスク**: プロジェクト初期化、依存関係、リンティング
     * **テストタスク [P]**: 契約ごとに1つ、統合シナリオごとに1つ
     * **コアタスク**: エンティティ、サービス、CLIコマンド、エンドポイントごとに1つ
     * **統合タスク**: DB接続、ミドルウェア、ログ
     * **仕上げタスク [P]**: ユニットテスト、パフォーマンス、ドキュメント

4. タスク生成ルール：
   - 各契約ファイル → [P]マークされた契約テストタスク
   - data-model内の各エンティティ → [P]マークされたモデル作成タスク
   - 各エンドポイント → 実装タスク（共有ファイルの場合は並列不可）
   - 各ユーザーストーリー → [P]マークされた統合テスト
   - 異なるファイル = 並列可能 [P]
   - 同じファイル = 順次（[P]なし）

5. 依存関係順でタスクを並べ替え：
   - すべての前にセットアップ
   - 実装前にテスト（TDD）
   - サービス前にモデル
   - エンドポイント前にサービス
   - 統合前にコア
   - 仕上げ前にすべて

6. 並列実行例を含める：
   - 一緒に実行できる[P]タスクをグループ化
   - 実際のTaskエージェントコマンドを表示

7. 以下でFEATURE_DIR/tasks.mdを作成：
   - 実装計画からの正しい機能名
   - 番号付きタスク（T001、T002など）
   - 各タスクの明確なファイルパス
   - 依存関係メモ
   - 並列実行ガイダンス

タスク生成のコンテキスト：{ARGS}

tasks.mdはすぐに実行可能である必要があります - 各タスクは、LLMが追加のコンテキストなしに完了できるほど具体的である必要があります。
